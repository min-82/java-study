C언어 vs Java (패러다임의 대전환)

C언어 (절차지향):

'순서'와 '동작(함수)'이 중심.
데이터(struct)와 함수가 분리되어 있어, 함수 호출 시 데이터를 넘겨줘야 함.
방식: "엔진을 켜라(자동차 A)" -> turn_on(&carA);

Java (객체지향):
'누가(객체)' 하는지가 중심.
데이터(Field)와 함수(Method)가 '클래스'라는 울타리에 한 몸으로 묶임.
방식: "자동차 A야, 엔진 켜!" -> carA.turnOn();
특징: 객체가 자기 데이터를 스스로 관리하고 책임짐.

클래스와 객체 (Class & Object)

클래스 (Class):
객체를 만들기 위한 '설계도' (붕어빵 틀).
코드로 작성한 .java 파일 그 자체.

객체 (Object/Instance):
설계도를 통해 힙(Heap) 메모리에 실제로 생성된 것 (슈크림 붕어빵).
생성 방법: Car myCar = new Car();
'new' 키워드가 메모리를 할당함 (C언어의 malloc과 유사).
Java는 free()가 없음. 가비지 컬렉터(GC)가 안 쓰는 객체를 알아서 청소함.

생성자 (Constructor)

정의:
객체가 생성될 때(new) 딱 한 번 실행되는 초기화 전용 메소드.
특징:
클래스 이름과 똑같아야 함.
리턴 타입(void, int 등)이 아예 없음.
생성자 오버로딩 (Overloading):
이름이 같아도 '매개변수(재료)의 개수나 타입'이 다르면 여러 개 만들 수 있음.
예: "모델명만 입력받는 생성자" vs "모델명+연료를 입력받는 생성자"

this()의 활용:
생성자끼리 서로를 호출할 때 사용 (코드 중복 제거).
규칙: 반드시 생성자의 '첫 번째 줄'에 와야 함.

this 키워드 (나 자신)
정의:
현재 코드를 실행 중인 '객체 자기 자신의 주소'를 가리키는 포인터.
사용하는 이유 (변수 숨김/Shadowing):
필드 이름(fuel)과 매개변수 이름(fuel)이 같을 때, 가까운 매개변수가 우선권을 가짐.
이때 "이건 매개변수가 아니라 내 필드야!"라고 지정하기 위해 this.fuel 사용.
핵심: 매개변수는 한시적으로 존재하므로, 그 짧은 순간의 이름 충돌을 해결하기 위함.

캡슐화 (Encapsulation) - 데이터 보호
목적:
객체의 중요 데이터를 외부의 오염(잘못된 값 대입)으로부터 보호.
접근 제어자:
private: "관계자 외 출입 금지". 클래스 내부에서만 접근 가능.
public: "모두 환영". 어디서든 접근 가능.

Getter / Setter (통로):
데이터는 private으로 잠그고, 메소드를 통해서만 접근하게 함.
Setter: 값을 넣을 때 '검증(Validation)' 수행. (예: if (fuel < 0) fuel = 0;)
Getter: 값을 안전하게 읽어옴. (this 생략 가능)

객체 배열 (Array of Objects)
C언어와 차이점:
배열을 만든다고 바로 객체가 생기는 것이 아님.
"객체를 담을 수 있는 빈 공간(참조 변수)"들만 생기는 것.
주의사항:
Car[] garage = new Car[3]; // 주차장 칸만 만듦 (아직 차 없음!)
garage[0] = new Car(); // 실제 자동차를 생성해서 칸에 넣어야 함 (필수!)

향상된 for문 (for-each):
for (Car c : garage) { ... }
인덱스(i) 없이 배열의 요소를 하나씩 꺼내서 순회할 때 편리함.

컴파일과 실행 (VS Code 환경)
파일 구분:
.java 파일: 사람이 읽는 소스 코드.
.class 파일: 컴파일러(javac)가 번역한 바이트 코드 (기계/JVM용).

특징:
VS Code(Java Extension)는 소스 폴더를 깔끔하게 유지하기 위해 .class 파일을 bin/ 등의 숨겨진 폴더에 따로 저장함.
실행 시(Run), main 메소드가 있는 클래스를 찾아 프로그램을 시작함.