C언어 vs Java (패러다임의 대전환)

C언어 (절차지향):

'순서'와 '동작(함수)'이 중심.
데이터(struct)와 함수가 분리되어 있어, 함수 호출 시 데이터를 넘겨줘야 함.
방식: "엔진을 켜라(자동차 A)" -> turn_on(&carA);

Java (객체지향):
'누가(객체)' 하는지가 중심.
데이터(Field)와 함수(Method)가 '클래스'라는 울타리에 한 몸으로 묶임.
방식: "자동차 A야, 엔진 켜!" -> carA.turnOn();
특징: 객체가 자기 데이터를 스스로 관리하고 책임짐.

클래스와 객체 (Class & Object)

클래스 (Class):
객체를 만들기 위한 '설계도' (붕어빵 틀).
코드로 작성한 .java 파일 그 자체.

객체 (Object/Instance):
설계도를 통해 힙(Heap) 메모리에 실제로 생성된 것 (슈크림 붕어빵).
생성 방법: Car myCar = new Car();
'new' 키워드가 메모리를 할당함 (C언어의 malloc과 유사).
Java는 free()가 없음. 가비지 컬렉터(GC)가 안 쓰는 객체를 알아서 청소함.

생성자 (Constructor)

정의:
객체가 생성될 때(new) 딱 한 번 실행되는 초기화 전용 메소드.
특징:
클래스 이름과 똑같아야 함.
리턴 타입(void, int 등)이 아예 없음.
생성자 오버로딩 (Overloading):
이름이 같아도 '매개변수(재료)의 개수나 타입'이 다르면 여러 개 만들 수 있음.
예: "모델명만 입력받는 생성자" vs "모델명+연료를 입력받는 생성자"

this()의 활용:
생성자끼리 서로를 호출할 때 사용 (코드 중복 제거).
규칙: 반드시 생성자의 '첫 번째 줄'에 와야 함.

this 키워드 (나 자신)
정의:
현재 코드를 실행 중인 '객체 자기 자신의 주소'를 가리키는 포인터.
사용하는 이유 (변수 숨김/Shadowing):
필드 이름(fuel)과 매개변수 이름(fuel)이 같을 때, 가까운 매개변수가 우선권을 가짐.
이때 "이건 매개변수가 아니라 내 필드야!"라고 지정하기 위해 this.fuel 사용.
핵심: 매개변수는 한시적으로 존재하므로, 그 짧은 순간의 이름 충돌을 해결하기 위함.

캡슐화 (Encapsulation) - 데이터 보호
목적:
객체의 중요 데이터를 외부의 오염(잘못된 값 대입)으로부터 보호.
접근 제어자:
private: "관계자 외 출입 금지". 클래스 내부에서만 접근 가능.
public: "모두 환영". 어디서든 접근 가능.

Getter / Setter (통로):
데이터는 private으로 잠그고, 메소드를 통해서만 접근하게 함.
Setter: 값을 넣을 때 '검증(Validation)' 수행. (예: if (fuel < 0) fuel = 0;)
Getter: 값을 안전하게 읽어옴. (this 생략 가능)

객체 배열 (Array of Objects)
C언어와 차이점:
배열을 만든다고 바로 객체가 생기는 것이 아님.
"객체를 담을 수 있는 빈 공간(참조 변수)"들만 생기는 것.
주의사항:
Car[] garage = new Car[3]; // 주차장 칸만 만듦 (아직 차 없음!)
garage[0] = new Car(); // 실제 자동차를 생성해서 칸에 넣어야 함 (필수!)

향상된 for문 (for-each):
for (Car c : garage) { ... }
인덱스(i) 없이 배열의 요소를 하나씩 꺼내서 순회할 때 편리함.

컴파일과 실행 (VS Code 환경)
파일 구분:
.java 파일: 사람이 읽는 소스 코드.
.class 파일: 컴파일러(javac)가 번역한 바이트 코드 (기계/JVM용).

특징:
VS Code(Java Extension)는 소스 폴더를 깔끔하게 유지하기 위해 .class 파일을 bin/ 등의 숨겨진 폴더에 따로 저장함.
실행 시(Run), main 메소드가 있는 클래스를 찾아 프로그램을 시작함.

상속 (Inheritance) - "부모의 모든 것을 물려받는다"
정의: 기존 클래스(부모)의 필드와 메소드를 그대로 물려받아 새로운 클래스(자식)를 만드는 것.
키워드: extends (확장)
문법: public class Truck extends Car { ... }
장점: 코드 중복 제거 (부모에 짠 코드를 다시 안 짜도 됨).
유지보수 용이 (부모만 고치면 자식들도 다 수정됨).
다형성의 기반이 됨.
특징: 자바는 '단일 상속'만 허용함 (부모는 오직 하나).
부모의 private 멤버는 상속은 되지만, 자식이 직접 접근할 수는 없음 (Getter/Setter 필요).

오버라이딩 (Overriding) - "부모 기능 재정의"
정의: 부모에게 물려받은 메소드의 내용을 자식 클래스에 맞게 뜯어고치는 것.
규칙: 메소드 이름, 매개변수, 리턴 타입이 부모와 똑같아야 함.
@Override 어노테이션을 붙여서 컴파일러에게 검사를 맡기는 것이 좋음.

오버로딩(Overloading)과 차이점:
오버로딩: 이름은 같지만 재료(매개변수)가 다른 '새로운' 메소드 생성 (new).
오버라이딩: 기존에 있던 메소드의 내용을 '덮어쓰기' (modify).

super와 this - "족보 정리"
this: '나 자신'을 가리키는 참조 변수.
this.name (내 변수), this() (내 생성자 호출).

super: '직계 부모'를 가리키는 참조 변수.
super.name (부모 변수), super.accelerate() (부모 메소드).
생성자 호출 규칙 (super()): 자식 객체를 만들 때는 반드시 부모 객체가 먼저 만들어져야 함.
따라서 자식 생성자의 '첫 번째 줄'에는 항상 super()가 숨겨져 있음.
생성자 체이닝: this()를 이용해 내 생성자끼리 연결하고, 마지막에 super()를 호출해 중복 코드를 줄임.

다형성 (Polymorphism) - "하나의 타입, 여러 가지 객체"
정의: 부모 타입의 참조 변수로 자식 타입의 객체를 다루는 기술.
코드: Car c = new Truck(); (업캐스팅)
효과: 배열 하나(Car[])로 트럭, 스포츠카, 버스를 한꺼번에 관리 가능.
메소드 매개변수(Car c)로 모든 차종을 다 받을 수 있음.

동적 바인딩 (Dynamic Binding): 타입은 부모(Car)지만, 실제 실행 시점에는 자식(Truck)의 오버라이딩된 메소드가 실행되는 현상.

instanceof 연산자: 실제 객체의 타입을 확인할 때 사용.
예: if (c instanceof Truck) { ... } -> 안전하게 다운캐스팅 가능.

추상 클래스 (Abstract Class) - "미완성 설계도"
정의: 하나 이상의 추상 메소드를 포함하거나, abstract 키워드가 붙은 클래스.
절대 객체 생성 불가 (new Car() 금지).

추상 메소드 (Abstract Method): 구현부 { ... } 가 없고 선언부만 있는 메소드.
예: public abstract void attack();
목적: 자식 클래스에게 "이 기능은 반드시 네가 직접 구현(강제)해라"고 명령.
사용하는 이유: 계층 구조(Hierarchy) 형성.
"전사는 직업의 일종이다(Is-A)"라는 본질적 공통점 묶기.

인터페이스 (Interface) - "기능 자격증 / 플러그인"
정의: 오직 상수(static final)와 추상 메소드만 가질 수 있는 일종의 규격서.
키워드: interface, implements (구현)
특징: 다중 상속(구현) 가능: class A implements B, C, D
관계없는 클래스끼리 공통 기능을 묶을 때 사용.
"전사는 탈것을 탈 수 있다(Can-Do)"와 같은 기능 부가.

추상 클래스 vs 인터페이스 비교:
추상 클래스: "혈연 관계" (본질, 공통 속성 물려주기).
인터페이스: "사회적 약속" (기능 장착, 표준 규격 준수).

실무 코드 구조 예시 (RPG 게임)
Job (추상 클래스):
모든 직업이 가져야 할 이름, HP 변수 관리.
attack() 메소드 구현 강제.
Warrior (자식 클래스):
Job을 상속받아 구체적인 전사로 탄생.
Mountable (인터페이스):
'탈것 탑승' 기능을 정의.
Warrior implements Mountable -> 전사에게만 말 타는 기능 부여.